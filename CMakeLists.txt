cmake_minimum_required(VERSION 3.31.0)
project(livekit VERSION 0.1.0 LANGUAGES C CXX)

# ---- C++ standard ----
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

if(MSVC)
  # Release: the prebuilt webrtc is using /MT, so we need to match that
  set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>" CACHE STRING "" FORCE)
endif()

############## Protobuf ################

# ---- Protobuf (FFI protos) ----
set(FFI_PROTO_DIR ${CMAKE_SOURCE_DIR}/client-sdk-rust/livekit-ffi/protocol)
set(FFI_PROTO_FILES
    ${FFI_PROTO_DIR}/handle.proto
    ${FFI_PROTO_DIR}/ffi.proto
    ${FFI_PROTO_DIR}/participant.proto
    ${FFI_PROTO_DIR}/room.proto
    ${FFI_PROTO_DIR}/track.proto
    ${FFI_PROTO_DIR}/video_frame.proto
    ${FFI_PROTO_DIR}/audio_frame.proto
    ${FFI_PROTO_DIR}/e2ee.proto
    ${FFI_PROTO_DIR}/stats.proto
    ${FFI_PROTO_DIR}/data_stream.proto
    ${FFI_PROTO_DIR}/rpc.proto
    ${FFI_PROTO_DIR}/track_publication.proto
)
set(PROTO_BINARY_DIR ${CMAKE_BINARY_DIR}/generated)
file(MAKE_DIRECTORY ${PROTO_BINARY_DIR})

find_package(Protobuf REQUIRED)
find_package(absl CONFIG REQUIRED)

# Object library that owns generated .pb.cc/.pb.h
add_library(livekit_proto OBJECT ${FFI_PROTO_FILES})
target_include_directories(livekit_proto PRIVATE
  "$<BUILD_INTERFACE:${PROTO_BINARY_DIR}>"
  ${Protobuf_INCLUDE_DIRS}
)
target_link_libraries(livekit_proto PRIVATE protobuf::libprotobuf)

# Generate .pb sources into ${PROTO_BINARY_DIR} and attach to livekit_proto
protobuf_generate(
  LANGUAGE cpp
  TARGET livekit_proto
  PROTOC_OUT_DIR ${PROTO_BINARY_DIR}
  IMPORT_DIRS ${FFI_PROTO_DIR}
)

########### auto-gen build.h #######################

# Where to place the generated header
set(GENERATED_INCLUDE_DIR "${CMAKE_CURRENT_BINARY_DIR}/generated")
file(MAKE_DIRECTORY "${GENERATED_INCLUDE_DIR}")

# Try to capture git commit; fall back to "unknown" if git isn't available or repo isn't present.
set(GIT_COMMIT "unknown")
find_package(Git QUIET)
if(GIT_FOUND AND EXISTS "${CMAKE_SOURCE_DIR}/.git")
  execute_process(
    COMMAND "${GIT_EXECUTABLE}" rev-parse --short HEAD
    WORKING_DIRECTORY "${CMAKE_SOURCE_DIR}"
    OUTPUT_VARIABLE GIT_COMMIT
    OUTPUT_STRIP_TRAILING_WHITESPACE
    ERROR_QUIET
  )
endif()

# Build timestamp
string(TIMESTAMP BUILD_DATE "%Y-%m-%d %H:%M:%S")

# Comment shown at the top of the generated header
set(GENERATED_COMMENT "This file was auto-generated by CMake on ${BUILD_DATE}. Do NOT edit manually. Edit build.h.in instead.")

# Generate the header from the template
# Version baked into build.h (CI can override: -DLIVEKIT_VERSION=0.1.0)
if(NOT DEFINED LIVEKIT_VERSION OR LIVEKIT_VERSION STREQUAL "")
  set(LIVEKIT_VERSION "0.0.0")
endif()
configure_file(
  "${CMAKE_CURRENT_SOURCE_DIR}/build.h.in"
  "${GENERATED_INCLUDE_DIR}/build.h"
  @ONLY
)

########### Livekit Rust SDK #######################

# Find cargo
find_program(CARGO_EXECUTABLE NAMES cargo REQUIRED)

set(RUST_ROOT ${CMAKE_SOURCE_DIR}/client-sdk-rust)

# Write a helper script that never passes empty args
set(RUN_CARGO_SCRIPT ${CMAKE_BINARY_DIR}/run_cargo.cmake)
file(WRITE ${RUN_CARGO_SCRIPT}
"if(NOT DEFINED CFG)
  set(CFG Debug)
endif()
if(NOT DEFINED RUST_ROOT)
  message(FATAL_ERROR \"RUST_ROOT not set\")
endif()
if(NOT DEFINED CARGO)
  message(FATAL_ERROR \"CARGO not set\")
endif()

# Build arg list
set(ARGS build)
if(NOT CFG STREQUAL \"Debug\")
  list(APPEND ARGS --release)
endif()

message(STATUS \"[run_cargo.cmake] CFG=\${CFG}  CARGO=\${CARGO}\")
execute_process(
  COMMAND \"\${CARGO}\" \${ARGS}
  WORKING_DIRECTORY \"\${RUST_ROOT}\"
  RESULT_VARIABLE rv
)
if(rv)
  message(FATAL_ERROR \"cargo build failed with code: \${rv}\")
endif()
")

# Imported Rust lib with per-config locations
add_library(livekit_ffi STATIC IMPORTED GLOBAL)
if (WIN32)
  set(RUST_LIB_DEBUG   "${RUST_ROOT}/target/debug/livekit_ffi.lib")
  set(RUST_LIB_RELEASE "${RUST_ROOT}/target/release/livekit_ffi.lib")
else()
  set(RUST_LIB_DEBUG   "${RUST_ROOT}/target/debug/liblivekit_ffi.a")
  set(RUST_LIB_RELEASE "${RUST_ROOT}/target/release/liblivekit_ffi.a")
endif()
set_target_properties(livekit_ffi PROPERTIES
  IMPORTED_CONFIGURATIONS "Debug;Release;RelWithDebInfo;MinSizeRel"
  IMPORTED_LOCATION_DEBUG   "${RUST_LIB_DEBUG}"
  IMPORTED_LOCATION_RELEASE "${RUST_LIB_RELEASE}"
  IMPORTED_LOCATION_RELWITHDEBINFO "${RUST_LIB_RELEASE}"
  IMPORTED_LOCATION_MINSIZEREL     "${RUST_LIB_RELEASE}"
)

# Custom target that runs the script; no empty args get passed to cargo
set(RUST_LIB "$<IF:$<CONFIG:Debug>,${RUST_LIB_DEBUG},${RUST_LIB_RELEASE}>")
add_custom_command(
  OUTPUT "${RUST_LIB_DEBUG}" "${RUST_LIB_RELEASE}"
  COMMAND "${CMAKE_COMMAND}"
          -DCFG=$<CONFIG>
          -DRUST_ROOT=${RUST_ROOT}
          -DCARGO=${CARGO_EXECUTABLE}
          -P "${RUN_CARGO_SCRIPT}"
  WORKING_DIRECTORY "${RUST_ROOT}"
  COMMENT "Building Rust FFI via cargo"
  VERBATIM
)
add_custom_target(build_rust_ffi ALL
  DEPENDS "${RUST_LIB_DEBUG}" "${RUST_LIB_RELEASE}"
)

if (UNIX AND NOT APPLE)
  # A workaround to strip out the protozero_plugin.o symbols which cause our examples fail to link on Linux.
  # Make sure CMAKE_AR is defined; if not, you can hardcode "ar"
  if(NOT CMAKE_AR)
    find_program(CMAKE_AR ar REQUIRED)
  endif()
  add_custom_command(
    TARGET build_rust_ffi
    POST_BUILD
    COMMAND ${CMAKE_AR} -dv "${RUST_LIB_RELEASE}" protozero_plugin.o
    COMMENT "Removing protozero_plugin.o (stray main) from liblivekit_ffi.a"
  )
endif()

# ---- C++ wrapper library ----
add_library(livekit
  include/livekit/audio_frame.h
  include/livekit/audio_source.h
  include/livekit/audio_stream.h
  include/livekit/data_stream.h
  include/livekit/e2ee.h
  include/livekit/room.h
  include/livekit/room_event_types.h
  include/livekit/room_delegate.h
  include/livekit/ffi_handle.h
  include/livekit/local_audio_track.h
  include/livekit/remote_audio_track.h
  include/livekit/participant.h
  include/livekit/local_participant.h
  include/livekit/remote_participant.h
  include/livekit/livekit.h
  include/livekit/rpc_error.h
  include/livekit/stats.h
  include/livekit/track.h
  include/livekit/track_publication.h
  include/livekit/local_track_publication.h
  include/livekit/remote_track_publication.h
  include/livekit/video_frame.h
  include/livekit/video_source.h
  include/livekit/video_stream.h
  include/livekit/local_video_track.h
  include/livekit/remote_video_track.h
  src/audio_frame.cpp
  src/audio_source.cpp
  src/audio_stream.cpp
  src/data_stream.cpp
  src/e2ee.cpp
  src/ffi_handle.cpp
  src/ffi_client.cpp
  src/ffi_client.h
  src/livekit.cpp
  src/local_audio_track.cpp
  src/remote_audio_track.cpp
  src/room.cpp
  src/room_proto_converter.cpp
  src/room_proto_converter.h
  src/local_participant.cpp
  src/remote_participant.cpp
  src/stats.cpp
  src/track.cpp
  src/track_proto_converter.cpp
  src/track_proto_converter.h
  src/track_publication.cpp
  src/local_track_publication.cpp
  src/remote_track_publication.cpp
  src/rpc_error.cpp
  src/video_frame.cpp
  src/video_source.cpp
  src/video_stream.cpp
  src/local_video_track.cpp
  src/remote_video_track.cpp
  src/video_utils.cpp
  src/video_utils.h
)

# Add generated proto objects to the wrapper
target_sources(livekit PRIVATE $<TARGET_OBJECTS:livekit_proto>)

target_include_directories(livekit PUBLIC
  $<BUILD_INTERFACE:${CMAKE_SOURCE_DIR}/include>
  $<INSTALL_INTERFACE:include>
)

target_include_directories(livekit PRIVATE
  ${CMAKE_SOURCE_DIR}/src
  ${RUST_ROOT}/livekit-ffi/include
  ${PROTO_BINARY_DIR}
  ${GENERATED_INCLUDE_DIR}
)

target_link_libraries(livekit
  PRIVATE
    livekit_ffi
    protobuf::libprotobuf
)
# Ensure protoc matches headers/libs
message(STATUS "Protobuf: version=${Protobuf_VERSION}; protoc=${Protobuf_PROTOC_EXECUTABLE}")

# Ensure cargo runs before we try to link livekit
add_dependencies(livekit build_rust_ffi)
add_custom_target(livekit_ffi_artifacts DEPENDS "${RUST_LIB_DEBUG}" "${RUST_LIB_RELEASE}")
add_dependencies(livekit livekit_ffi_artifacts)

########### Platform specific settings  ########### 

if(APPLE)
# (12.3 is when ScreenCaptureKit was introduced)
if(NOT DEFINED CMAKE_OSX_DEPLOYMENT_TARGET OR CMAKE_OSX_DEPLOYMENT_TARGET VERSION_LESS "12.3")
  set(CMAKE_OSX_DEPLOYMENT_TARGET "12.3" CACHE STRING "Minimum macOS version" FORCE)
endif()

  find_library(FW_COREAUDIO      CoreAudio      REQUIRED)
  find_library(FW_AUDIOTOOLBOX   AudioToolbox   REQUIRED)
  find_library(FW_COREFOUNDATION CoreFoundation REQUIRED)
  find_library(FW_SECURITY       Security       REQUIRED)
  find_library(FW_COREGRAPHICS   CoreGraphics   REQUIRED)
  find_library(FW_COREMEDIA      CoreMedia      REQUIRED)
  find_library(FW_VIDEOTOOLBOX   VideoToolbox   REQUIRED)
  find_library(FW_AVFOUNDATION   AVFoundation   REQUIRED)
  find_library(FW_COREVIDEO      CoreVideo      REQUIRED)
  find_library(FW_FOUNDATION     Foundation     REQUIRED)
  find_library(FW_APPKIT         AppKit         REQUIRED) 
  find_library(FW_QUARTZCORE     QuartzCore     REQUIRED)
  find_library(FW_OPENGL         OpenGL         REQUIRED)
  find_library(FW_IOSURFACE      IOSurface      REQUIRED)
  find_library(FW_METAL          Metal          REQUIRED)
  find_library(FW_METALKIT       MetalKit       REQUIRED)
  find_library(FW_SCREENCAPTUREKIT ScreenCaptureKit REQUIRED)

  target_link_libraries(livekit PUBLIC
    ${FW_COREAUDIO}
    ${FW_AUDIOTOOLBOX}
    ${FW_COREFOUNDATION}
    ${FW_SECURITY}
    ${FW_COREGRAPHICS}
    ${FW_COREMEDIA}
    ${FW_VIDEOTOOLBOX}
    ${FW_AVFOUNDATION}
    ${FW_COREVIDEO}
    ${FW_FOUNDATION}
    ${FW_APPKIT}
    ${FW_QUARTZCORE}
    ${FW_OPENGL}
    ${FW_IOSURFACE}
    ${FW_METAL}
    ${FW_METALKIT}
    ${FW_SCREENCAPTUREKIT}
  )

  # Ensure Objective-C categories/classes in static archives are loaded (WebRTC needs this)
  # Use LINKER: to guarantee it is passed to the linker (CMake >= 3.13)
  target_link_options(livekit INTERFACE "LINKER:-ObjC")
endif()

# Only Protobuf >= 6 needs Abseil
if (Protobuf_VERSION VERSION_GREATER_EQUAL 6.0)
  # Some distros export as "Abseil::"
  find_package(absl CONFIG QUIET)
  if (NOT absl_FOUND)
    find_package(Abseil QUIET)
  endif()

  if (absl_FOUND)
    target_link_libraries(livekit PRIVATE
      absl::log
      absl::check
      absl::strings
      absl::base
    )
  elseif (Abseil_FOUND)
    target_link_libraries(livekit PRIVATE
      Abseil::log
      Abseil::check
      Abseil::strings
      Abseil::base
    )
  else()
    message(FATAL_ERROR
      "Protobuf ${Protobuf_VERSION} requires Abseil but no CMake package was found.\n"
      "Install Abseil (macOS: 'brew install abseil', Ubuntu: 'sudo apt-get install libabsl-dev'), "
      "or use Protobuf < 6.")
  endif()
else()
  message(STATUS "Protobuf < 6 detected; skipping Abseil linking.")
endif()

# On Linux, it needs to link OpenSSL
if(UNIX AND NOT APPLE)
  find_package(OpenSSL REQUIRED)
  target_link_libraries(livekit PRIVATE OpenSSL::SSL OpenSSL::Crypto)
endif()


# Warnings
if (MSVC)
  target_compile_options(livekit PRIVATE /permissive- /Zc:__cplusplus /W4)
else()
  target_compile_options(livekit PRIVATE -Wall -Wextra -Wpedantic)
endif()

# -------------------- Install / Package (SDK bundle) --------------------
include(GNUInstallDirs)
include(CMakePackageConfigHelpers)

set(LIVEKIT_PACKAGE_NAME "LiveKit")
set(LIVEKIT_EXPORT_NAMESPACE "LiveKit::")

# Install the library target
install(TARGETS livekit
  EXPORT LiveKitTargets
  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}   # Windows .dll
  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}   # .so/.dylib
  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}   # .a/.lib
  INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
)

# Install public headers
install(DIRECTORY "${CMAKE_SOURCE_DIR}/include/"
  DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
  FILES_MATCHING PATTERN "*.h" PATTERN "*.hpp"
)

# Install generated build.h if it is part of the public headers
install(FILES "${GENERATED_INCLUDE_DIR}/build.h"
  DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}/livekit"
)

# ---- Create Config + Version + Targets for find_package(LiveKit CONFIG) ----

# cmake/LiveKitConfig.cmake.in must exist in your repo
configure_package_config_file(
  "${CMAKE_SOURCE_DIR}/cmake/LiveKitConfig.cmake.in"
  "${CMAKE_CURRENT_BINARY_DIR}/LiveKitConfig.cmake"
  INSTALL_DESTINATION "${CMAKE_INSTALL_LIBDIR}/cmake/${LIVEKIT_PACKAGE_NAME}"
)

# Generate a version file automatically from project(VERSION ...)
write_basic_package_version_file(
  "${CMAKE_CURRENT_BINARY_DIR}/LiveKitConfigVersion.cmake"
  VERSION "${PROJECT_VERSION}"
  COMPATIBILITY SameMajorVersion
)

# Export targets
install(EXPORT LiveKitTargets
  FILE LiveKitTargets.cmake
  NAMESPACE ${LIVEKIT_EXPORT_NAMESPACE}
  DESTINATION "${CMAKE_INSTALL_LIBDIR}/cmake/${LIVEKIT_PACKAGE_NAME}"
)

# Install config files
install(FILES
  "${CMAKE_CURRENT_BINARY_DIR}/LiveKitConfig.cmake"
  "${CMAKE_CURRENT_BINARY_DIR}/LiveKitConfigVersion.cmake"
  DESTINATION "${CMAKE_INSTALL_LIBDIR}/cmake/${LIVEKIT_PACKAGE_NAME}"
)

# ------------------------------------------------------------------------

# ---- Examples ----
add_subdirectory(examples)


# ---------- Clean helpers ----------
# Removes generated protobuf sources
add_custom_target(clean_generated
  COMMAND ${CMAKE_COMMAND} -E echo "Removing generated protobufs: ${PROTO_BINARY_DIR}"
  COMMAND ${CMAKE_COMMAND} -E rm -rf "${PROTO_BINARY_DIR}"
  COMMENT "Clean generated protobuf files"
  VERBATIM
)

# Cargo clean (safer, lets Cargo decide what to delete)
add_custom_target(cargo_clean
  COMMAND ${CMAKE_COMMAND} -E echo "Running 'cargo clean' in: ${RUST_ROOT}"
  COMMAND "${CARGO_EXECUTABLE}" clean
  WORKING_DIRECTORY "${RUST_ROOT}"
  COMMENT "Clean Rust target directory via cargo"
  VERBATIM
)

# Combined "clean-all" (C++ clean + generated + cargo)
# Note: 'clean' is CMake's built-in target that removes CMake-built artifacts.
add_custom_target(clean_all
  # 1) CMake clean (object files, libs, exes)
  COMMAND ${CMAKE_COMMAND} -E echo "==> CMake clean in: ${CMAKE_BINARY_DIR}"
  COMMAND ${CMAKE_COMMAND} --build "${CMAKE_BINARY_DIR}" --target clean
  # 2) Cargo clean (Rust target/)
  COMMAND ${CMAKE_COMMAND} -E echo "==> cargo clean in: ${RUST_ROOT}"
  COMMAND ${CMAKE_COMMAND} -E chdir "${RUST_ROOT}" "${CARGO_EXECUTABLE}" clean
  # 3) Remove generated protobufs (lives under build/)
  COMMAND ${CMAKE_COMMAND} -E echo "==> removing generated protobufs: ${PROTO_BINARY_DIR}"
  COMMAND ${CMAKE_COMMAND} -E rm -rf "${PROTO_BINARY_DIR}"
  # 4) Remove the entire build directory (like `rm -rf build`)
  #    Switch to SOURCE dir first so removing BINARY dir is always safe.
  COMMAND ${CMAKE_COMMAND} -E echo "==> removing build directory: ${CMAKE_BINARY_DIR}"
  COMMAND ${CMAKE_COMMAND} -E chdir "${CMAKE_SOURCE_DIR}" ${CMAKE_COMMAND} -E rm -rf "${CMAKE_BINARY_DIR}"
  COMMENT "Full clean: CMake outputs + Rust target + generated protos + delete build/"
  VERBATIM
)